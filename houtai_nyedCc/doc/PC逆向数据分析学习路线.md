# PC逆向数据分析学习路线

> **文档版本**：v1.0
> **创建日期**：2025-11-24
> **适用人群**：想系统学习游戏/软件逆向数据分析的技术人员
> **声明**：本文档仅用于技术学习研究，请遵守相关法律法规

---

## 一、学习路线总览

```
                                    ┌─────────────────────────────┐
                                    │      逆向数据分析学习体系     │
                                    └──────────────┬──────────────┘
                                                   │
                    ┌──────────────────────────────┼──────────────────────────────┐
                    │                              │                              │
                    ▼                              ▼                              ▼
          ┌─────────────────┐           ┌─────────────────┐           ┌─────────────────┐
          │    基础知识层    │           │    PC端逆向     │           │   移动端逆向    │
          │  (必修 2-4月)   │           │   (核心 4-8月)  │           │  (进阶 3-6月)   │
          └────────┬────────┘           └────────┬────────┘           └────────┬────────┘
                   │                             │                             │
     ┌─────────────┼─────────────┐    ┌─────────┴─────────┐         ┌─────────┴─────────┐
     │             │             │    │                   │         │                   │
     ▼             ▼             ▼    ▼                   ▼         ▼                   ▼
┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐    ┌─────────┐ ┌─────────┐      ┌─────────┐
│ 编程语言 │ │ 汇编语言 │ │ 操作系统 │ │ 静态分析 │    │ 动态调试 │ │ Android │      │   iOS   │
│ C/C++   │ │ x86/x64 │ │ Windows │ │ IDA Pro │    │ x64dbg  │ │  逆向   │      │  逆向   │
└─────────┘ └─────────┘ └─────────┘ └─────────┘    └─────────┘ └─────────┘      └─────────┘
```

---

## 二、第一阶段：基础知识（必修）

### 2.1 编程语言基础

#### 2.1.1 C/C++ 语言（核心必修）

```
C/C++ 学习路线
├── 第1周：C语言基础
│   ├── 数据类型与变量
│   ├── 指针与内存管理
│   ├── 数组与字符串
│   ├── 函数与调用约定
│   └── 结构体与联合体
├── 第2-3周：C语言进阶
│   ├── 指针的指针（多级指针）
│   ├── 函数指针
│   ├── 动态内存分配（malloc/free）
│   ├── 文件操作
│   └── 位运算
├── 第4-6周：C++基础
│   ├── 类与对象
│   ├── 继承与多态
│   ├── 虚函数与虚表（逆向重点）
│   ├── 模板与STL
│   └── 智能指针
└── 第7-8周：Windows编程
    ├── Win32 API 基础
    ├── 进程与线程
    ├── 内存操作 API
    └── DLL 编写与加载
```

**重点掌握（逆向必备）**：

| 知识点 | 逆向中的应用 | 重要程度 |
|--------|--------------|----------|
| 指针操作 | 内存地址读写、多级指针遍历 | ★★★★★ |
| 虚函数/虚表 | 分析C++对象、HOOK虚函数 | ★★★★★ |
| 结构体内存布局 | 还原游戏数据结构 | ★★★★★ |
| 调用约定 | 分析函数参数传递 | ★★★★☆ |
| 位运算 | 分析加密算法、标志位 | ★★★★☆ |

#### 2.1.2 Python 语言（辅助工具）

```
Python 学习重点
├── 基础语法（1周）
├── 文件与数据处理
├── struct 模块（二进制解析）
├── socket 网络编程
├── ctypes（调用C函数）
└── 常用库
    ├── pefile（PE文件分析）
    ├── capstone（反汇编引擎）
    ├── keystone（汇编引擎）
    ├── frida（动态注入框架）
    └── pymem（内存读写）
```

---

### 2.2 汇编语言学习（核心重点）

#### 2.2.1 x86 汇编基础

```
x86 汇编学习路线（4-6周）
│
├── 第1周：基础概念
│   ├── CPU 架构与寄存器
│   │   ├── 通用寄存器：EAX, EBX, ECX, EDX
│   │   ├── 指针寄存器：ESP, EBP, ESI, EDI
│   │   ├── 指令指针：EIP
│   │   └── 标志寄存器：EFLAGS
│   ├── 内存寻址模式
│   │   ├── 立即寻址：mov eax, 100
│   │   ├── 寄存器寻址：mov eax, ebx
│   │   ├── 直接寻址：mov eax, [0x401000]
│   │   ├── 寄存器间接：mov eax, [ebx]
│   │   └── 基址+偏移：mov eax, [ebx+0x10]
│   └── 数据类型
│       ├── BYTE (1字节)
│       ├── WORD (2字节)
│       ├── DWORD (4字节)
│       └── QWORD (8字节)
│
├── 第2周：基本指令
│   ├── 数据传送指令
│   │   ├── MOV：数据移动
│   │   ├── LEA：加载有效地址
│   │   ├── PUSH/POP：栈操作
│   │   └── XCHG：交换数据
│   ├── 算术指令
│   │   ├── ADD/SUB：加减
│   │   ├── MUL/DIV：乘除
│   │   ├── INC/DEC：自增自减
│   │   └── NEG：取负
│   ├── 逻辑指令
│   │   ├── AND/OR/XOR/NOT
│   │   ├── SHL/SHR：逻辑移位
│   │   ├── SAL/SAR：算术移位
│   │   └── ROL/ROR：循环移位
│   └── 比较与跳转
│       ├── CMP：比较
│       ├── TEST：测试
│       ├── JMP：无条件跳转
│       └── 条件跳转：JE/JNE/JG/JL/JA/JB...
│
├── 第3周：函数与调用
│   ├── 栈帧结构
│   │   ├── 函数序言（Prologue）
│   │   │   push ebp
│   │   │   mov ebp, esp
│   │   │   sub esp, XX
│   │   ├── 局部变量：[ebp-XX]
│   │   ├── 函数参数：[ebp+XX]
│   │   └── 函数尾声（Epilogue）
│   │       mov esp, ebp
│   │       pop ebp
│   │       ret
│   ├── 调用约定
│   │   ├── cdecl：调用者清栈，参数从右到左
│   │   ├── stdcall：被调用者清栈，参数从右到左
│   │   ├── fastcall：前2参数用ECX/EDX，其余入栈
│   │   └── thiscall：this指针用ECX
│   └── CALL/RET 指令
│       ├── CALL：压入返回地址，跳转
│       └── RET：弹出返回地址，返回
│
├── 第4周：高级主题
│   ├── 字符串操作
│   │   ├── MOVS/CMPS/SCAS
│   │   ├── REP 前缀
│   │   └── 方向标志 DF
│   ├── 浮点运算（FPU/SSE）
│   │   ├── FPU 栈式计算
│   │   ├── SSE 向量运算
│   │   └── XMM 寄存器
│   └── 系统指令
│       ├── INT：中断调用
│       ├── SYSENTER/SYSCALL
│       └── 特权指令
│
└── 第5-6周：实战练习
    ├── 手写简单汇编程序
    ├── 阅读反汇编代码
    ├── 识别编译器生成的模式
    └── 分析简单 CrackMe
```

#### 2.2.2 x64 汇编扩展

```
x64 与 x86 的主要区别
│
├── 寄存器扩展
│   ├── RAX, RBX, RCX, RDX（64位扩展）
│   ├── RSP, RBP, RSI, RDI
│   ├── R8-R15（新增8个通用寄存器）
│   └── RIP（指令指针）
│
├── 调用约定变化
│   ├── Windows x64
│   │   ├── 前4参数：RCX, RDX, R8, R9
│   │   ├── 其余参数入栈
│   │   ├── 调用者预留32字节影子空间
│   │   └── 返回值：RAX
│   └── Linux x64 (System V ABI)
│       ├── 前6参数：RDI, RSI, RDX, RCX, R8, R9
│       ├── 浮点参数：XMM0-XMM7
│       └── 返回值：RAX, RDX
│
├── 寻址变化
│   ├── RIP 相对寻址（默认）
│   └── 地址空间扩展到 48 位
│
└── 指令变化
    ├── 部分指令不再支持
    ├── 新增 MOVSXD（符号扩展）
    └── REX 前缀
```

#### 2.2.3 常见代码模式识别

```
编译器生成的典型模式
│
├── if-else 结构
│   │   cmp eax, ebx
│   │   jne else_branch
│   │   ; if 代码块
│   │   jmp end_if
│   │   else_branch:
│   │   ; else 代码块
│   │   end_if:
│
├── for 循环
│   │   mov ecx, 0          ; i = 0
│   │   loop_start:
│   │   cmp ecx, 10         ; i < 10
│   │   jge loop_end
│   │   ; 循环体
│   │   inc ecx             ; i++
│   │   jmp loop_start
│   │   loop_end:
│
├── while 循环
│   │   loop_start:
│   │   cmp eax, 0
│   │   je loop_end
│   │   ; 循环体
│   │   jmp loop_start
│   │   loop_end:
│
├── switch-case
│   │   ; 跳转表方式
│   │   cmp eax, max_case
│   │   ja default_case
│   │   jmp [jump_table + eax*4]
│
├── 虚函数调用
│   │   mov eax, [ecx]      ; 获取虚表指针
│   │   mov edx, [eax+0x10] ; 获取虚函数地址
│   │   call edx            ; 调用虚函数
│
└── 结构体访问
    │   mov eax, [ebx+0x00] ; 成员1
    │   mov ecx, [ebx+0x04] ; 成员2
    │   mov edx, [ebx+0x08] ; 成员3
```

#### 2.2.4 汇编学习资源

| 资源类型 | 推荐内容 | 说明 |
|----------|----------|------|
| 书籍 | 《汇编语言》王爽 | 入门经典，16位DOS环境 |
| 书籍 | 《x86汇编语言：从实模式到保护模式》 | 深入理解CPU |
| 书籍 | 《Intel 64 and IA-32 软件开发手册》 | 官方参考手册 |
| 视频 | B站 小甲鱼汇编教程 | 入门友好 |
| 工具 | MASM/NASM/FASM | 汇编器 |
| 练习 | CrackMe 程序 | 实战练习 |

---

### 2.3 操作系统原理

#### 2.3.1 Windows 核心概念

```
Windows 逆向必备知识
│
├── 进程与内存
│   ├── 进程地址空间
│   │   ├── 用户空间：0x00000000 - 0x7FFFFFFF
│   │   └── 内核空间：0x80000000 - 0xFFFFFFFF
│   ├── 虚拟内存机制
│   │   ├── 页表（PTE/PDE）
│   │   ├── 物理地址转换
│   │   └── 内存保护属性
│   └── 内存区域
│       ├── 代码段（.text）
│       ├── 数据段（.data/.rdata/.bss）
│       ├── 堆（Heap）
│       └── 栈（Stack）
│
├── PE 文件结构（重点）
│   ├── DOS Header
│   │   └── e_lfanew 指向 PE 头
│   ├── PE Header (IMAGE_NT_HEADERS)
│   │   ├── Signature ("PE\0\0")
│   │   ├── FileHeader
│   │   │   ├── Machine（CPU类型）
│   │   │   ├── NumberOfSections
│   │   │   └── Characteristics
│   │   └── OptionalHeader
│   │       ├── AddressOfEntryPoint（入口点RVA）
│   │       ├── ImageBase（基址）
│   │       ├── SectionAlignment
│   │       └── DataDirectory（数据目录）
│   ├── Section Headers
│   │   ├── .text（代码段）
│   │   ├── .data（已初始化数据）
│   │   ├── .rdata（只读数据）
│   │   ├── .bss（未初始化数据）
│   │   └── .rsrc（资源）
│   └── 重要数据目录
│       ├── 导入表（IAT）
│       ├── 导出表（EAT）
│       ├── 重定位表
│       └── TLS 表
│
├── 模块与加载
│   ├── DLL 加载机制
│   │   ├── 静态加载（LoadTime）
│   │   ├── 动态加载（LoadLibrary）
│   │   └── 延迟加载（Delay Load）
│   ├── 导入地址表（IAT）
│   │   ├── 运行时填充真实地址
│   │   └── IAT HOOK 原理
│   └── 模块枚举
│       ├── PEB->Ldr->模块链表
│       └── EnumProcessModules
│
└── 重要 API
    ├── 进程相关
    │   ├── OpenProcess
    │   ├── CreateProcess
    │   └── TerminateProcess
    ├── 内存相关
    │   ├── ReadProcessMemory
    │   ├── WriteProcessMemory
    │   ├── VirtualAllocEx
    │   └── VirtualProtectEx
    ├── 模块相关
    │   ├── GetModuleHandle
    │   ├── GetProcAddress
    │   └── LoadLibrary
    └── 线程相关
        ├── CreateThread
        ├── CreateRemoteThread
        └── SuspendThread/ResumeThread
```

---

## 三、第二阶段：PC端逆向分析

### 3.1 静态分析技术

#### 3.1.1 IDA Pro 使用

```
IDA Pro 学习路线
│
├── 基础操作（第1周）
│   ├── 界面布局
│   │   ├── IDA View（反汇编视图）
│   │   ├── Hex View（十六进制视图）
│   │   ├── Strings（字符串窗口）
│   │   ├── Imports/Exports（导入导出）
│   │   └── Functions（函数列表）
│   ├── 导航操作
│   │   ├── G：跳转到地址
│   │   ├── X：交叉引用
│   │   ├── N：重命名
│   │   ├── ;：添加注释
│   │   └── Enter/Esc：跳转/返回
│   └── 视图切换
│       ├── 文本视图 vs 图形视图
│       ├── 伪代码视图（F5）
│       └── 十六进制视图
│
├── 分析技巧（第2-3周）
│   ├── 字符串定位
│   │   ├── Shift+F12：字符串窗口
│   │   ├── Alt+T：文本搜索
│   │   └── 通过字符串找关键函数
│   ├── 交叉引用
│   │   ├── X：查看引用
│   │   ├── Ctrl+X：查看所有引用
│   │   └── 追踪数据/代码引用
│   ├── 函数分析
│   │   ├── 识别函数边界
│   │   ├── 参数与局部变量
│   │   ├── 调用图（View -> Graphs）
│   │   └── 函数类型设置（Y键）
│   └── 数据结构
│       ├── 创建结构体（Shift+F9）
│       ├── 应用结构体到数据
│       └── 枚举类型定义
│
├── 高级功能（第4周）
│   ├── 签名识别（FLIRT）
│   │   ├── 库函数识别
│   │   ├── 添加自定义签名
│   │   └── 编译器识别
│   ├── 类型库（TIL）
│   │   ├── 导入Windows类型
│   │   ├── 自定义类型库
│   │   └── 结构体导入
│   ├── IDAPython 脚本
│   │   ├── 基本API使用
│   │   ├── 批量重命名
│   │   ├── 自动化分析
│   │   └── 插件开发
│   └── 调试功能
│       ├── 本地调试
│       ├── 远程调试
│       └── 条件断点
│
└── 常用快捷键
    ├── 空格：切换文本/图形视图
    ├── F5：生成伪代码（需Hex-Rays）
    ├── Tab：在反汇编和伪代码间切换
    ├── Y：修改变量/函数类型
    ├── H：十进制/十六进制切换
    ├── R：字符显示
    ├── O：偏移量显示
    └── D：数据类型切换（db/dw/dd）
```

#### 3.1.2 Ghidra 使用（免费替代）

```
Ghidra 特点与使用
│
├── 优势
│   ├── 完全免费开源
│   ├── 反编译能力强
│   ├── 支持多种架构
│   └── 可扩展性好
│
├── 基本操作
│   ├── 项目管理
│   ├── 代码浏览器
│   ├── 反编译窗口
│   └── 函数图表
│
├── 与 IDA 对比
│   ├── 反编译：各有优劣
│   ├── 界面：IDA 更成熟
│   ├── 插件：IDA 生态更丰富
│   └── 价格：Ghidra 免费
│
└── 推荐场景
    ├── 预算有限
    ├── 学习入门
    └── 批量分析
```

---

### 3.2 动态调试技术

#### 3.2.1 x64dbg 调试器

```
x64dbg 学习路线
│
├── 界面熟悉（第1天）
│   ├── CPU 窗口（反汇编+寄存器+栈+内存）
│   ├── 日志窗口
│   ├── 断点窗口
│   ├── 内存映射
│   ├── 调用栈
│   └── 线程列表
│
├── 基本调试（第1周）
│   ├── 断点类型
│   │   ├── F2：软件断点（INT3）
│   │   ├── 硬件断点（最多4个）
│   │   │   ├── 执行断点
│   │   │   ├── 写入断点
│   │   │   └── 访问断点
│   │   └── 内存断点（页属性）
│   ├── 执行控制
│   │   ├── F9：运行
│   │   ├── F7：步入（Step Into）
│   │   ├── F8：步过（Step Over）
│   │   ├── Ctrl+F9：执行到返回
│   │   └── F4：执行到光标
│   ├── 数据查看
│   │   ├── 寄存器修改
│   │   ├── 内存查看/修改
│   │   ├── 栈查看
│   │   └── 跟踪数据变化
│   └── 搜索功能
│       ├── Ctrl+B：搜索字节
│       ├── Ctrl+F：搜索指令
│       └── 搜索字符串
│
├── 高级技巧（第2-3周）
│   ├── 条件断点
│   │   ├── 寄存器条件：eax == 0x100
│   │   ├── 内存条件：[esp+4] == "test"
│   │   ├── 命中次数
│   │   └── 日志断点
│   ├── 跟踪功能
│   │   ├── 指令跟踪
│   │   ├── 函数跟踪
│   │   └── 跟踪记录分析
│   ├── 脚本功能
│   │   ├── 内置脚本语言
│   │   ├── Python 脚本
│   │   └── 自动化分析
│   └── 插件使用
│       ├── ScyllaHide（反反调试）
│       ├── x64dbg-Plugin-Manager
│       ├── SharpOD（反调试）
│       └── Labeless（IDA联动）
│
└── 常用快捷键
    ├── F2：设置/取消断点
    ├── F7：单步步入
    ├── F8：单步步过
    ├── F9：运行
    ├── Ctrl+G：跳转到地址
    ├── Ctrl+E：编辑数据
    ├── ;：添加注释
    └── Ctrl+*：设置书签
```

#### 3.2.2 Cheat Engine 内存分析

```
Cheat Engine 使用技巧
│
├── 基础搜索（第1周）
│   ├── 数值搜索
│   │   ├── 精确值搜索
│   │   ├── 未知初始值
│   │   ├── 增加/减少搜索
│   │   └── 变化/未变化搜索
│   ├── 数据类型
│   │   ├── 1/2/4/8 字节整数
│   │   ├── Float/Double 浮点数
│   │   ├── 字符串
│   │   └── 数组/字节组
│   └── 扫描选项
│       ├── 快速扫描（对齐）
│       ├── 暂停扫描
│       └── 撤销扫描
│
├── 指针扫描（第2周）
│   ├── 为什么需要指针
│   │   └── 动态地址每次重启都变化
│   ├── 指针扫描步骤
│   │   ├── 找到目标地址
│   │   ├── 生成指针地址映射
│   │   ├── 设置指针扫描选项
│   │   │   ├── 最大偏移
│   │   │   ├── 最大层级
│   │   │   └── 指向的地址
│   │   └── 重启游戏验证
│   └── 指针链结构
│       └── [[[[base]+offset1]+offset2]+offset3]
│
├── 代码分析（第3周）
│   ├── 找出是什么访问了这个地址
│   │   ├── 右键 -> Find out what accesses
│   │   ├── 获取读取该地址的代码
│   │   └── 分析汇编指令
│   ├── 找出是什么写入了这个地址
│   │   ├── 右键 -> Find out what writes
│   │   ├── 定位修改代码
│   │   └── 分析修改逻辑
│   └── 代码注入
│       ├── Auto Assemble
│       ├── 代码洞注入
│       └── AOB（数组特征码）注入
│
├── 高级功能（第4周）
│   ├── 结构体分析
│   │   ├── Dissect data structures
│   │   ├── 自动分析结构体
│   │   └── 手动定义结构
│   ├── Lua 脚本
│   │   ├── 脚本基础语法
│   │   ├── 内存读写函数
│   │   ├── 热键绑定
│   │   └── 自动化功能
│   ├── 调试功能
│   │   ├── 内置调试器
│   │   ├── VEH 调试器
│   │   └── 断点设置
│   └── Cheat Table
│       ├── 保存/加载表
│       ├── 分享表文件
│       └── 表文件加密
│
└── 实战流程
    1. 搜索已知数值（如血量100）
    2. 改变数值后再次搜索
    3. 重复直到找到唯一地址
    4. 分析是什么代码访问该地址
    5. 找到基址或进行指针扫描
    6. 验证指针链的有效性
    7. 编写修改脚本或注入代码
```

---

### 3.3 内存偏移寻找

#### 3.3.1 基础概念

```
内存地址类型
│
├── 静态地址
│   ├── 定义：相对于模块基址的固定偏移
│   ├── 特点：模块每次加载地址可能变化，但偏移固定
│   ├── 表示：模块基址 + 偏移
│   └── 示例：game.exe + 0x12345
│
├── 动态地址
│   ├── 定义：每次运行都会变化的地址
│   ├── 原因：堆内存分配、对象创建
│   └── 解决：通过指针链找到
│
└── 指针链
    ├── 定义：从静态地址出发，通过多级偏移到达目标
    ├── 结构：[[[base+offset1]+offset2]+offset3]+offset4
    └── 示例：
        game.exe+0x100000    → 指向 0x12340000
        0x12340000+0x20      → 指向 0x56780000
        0x56780000+0x8       → 指向 0xABCD0000
        0xABCD0000+0x10      → 目标数据（如血量）
```

#### 3.3.2 寻找偏移的方法

```
方法一：CE 数值搜索法
│
├── 步骤
│   1. 打开 CE，附加到游戏进程
│   2. 搜索已知数值（如当前血量）
│   3. 改变数值（受伤或吃药）
│   4. 再次搜索新的数值
│   5. 重复直到结果唯一
│   6. 记录找到的地址
│
├── 技巧
│   ├── 不知道具体数值时用"未知初始值"
│   ├── 数值增加用"增加的值"
│   ├── 数值减少用"减少的值"
│   ├── 未变化用"未变化的值"
│   └── 浮点数注意类型选择
│
└── 局限性
    └── 只能找到有明确数值的数据


方法二：代码定位法
│
├── 步骤
│   1. 找到目标地址（通过方法一）
│   2. 右键 "Find out what accesses/writes this address"
│   3. 触发游戏中的相关操作
│   4. 查看捕获的汇编代码
│   5. 分析代码中的偏移和基址
│
├── 代码分析示例
│   │   mov eax, [esi+0x100]   ; esi是对象基址，0x100是血量偏移
│   │   sub eax, ecx           ; ecx是伤害值
│   │   mov [esi+0x100], eax   ; 写回血量
│   │
│   └── 从这段代码可知：
│       ├── 血量偏移 = 0x100
│       └── 需要找到 esi（对象基址）的来源
│
└── 继续追踪
    ├── 对 esi 下断点
    ├── 追踪 esi 从哪里来
    └── 最终找到静态基址


方法三：特征码定位法
│
├── 原理
│   ├── 代码在内存中的字节序列是固定的
│   ├── 通过搜索特征字节找到代码位置
│   └── 从代码中提取偏移和基址
│
├── 步骤
│   1. 在调试器中找到关键代码
│   2. 复制代码的字节序列
│   3. 创建特征码（部分用通配符??）
│   4. 下次搜索特征码定位代码
│   5. 从代码中动态读取偏移
│
└── 特征码示例
    原始字节：8B 86 00 01 00 00 2B C1 89 86 00 01 00 00
    特征码：  8B 86 ?? ?? ?? ?? 2B C1 89 86
    说明：    ?? 表示通配符，匹配任意字节


方法四：结构体分析法
│
├── 原理
│   ├── 游戏数据通常以结构体形式存储
│   ├── 相关数据在内存中相邻存放
│   └── 找到一个成员可以推断其他成员
│
├── CE 结构体分析
│   1. 找到一个已知数据的地址
│   2. 右键 "Browse this memory region"
│   3. Tools -> Dissect data/structures
│   4. 分析周围的内存数据
│   5. 识别其他有意义的数据
│
└── 常见结构体布局
    角色对象示例（偏移可能因游戏而异）：
    +0x000: 虚表指针
    +0x004: 对象ID
    +0x008: 对象名称指针
    +0x010: X 坐标 (float)
    +0x014: Y 坐标 (float)
    +0x018: Z 坐标 (float)
    +0x020: 当前血量
    +0x024: 最大血量
    +0x028: 当前蓝量
    +0x02C: 最大蓝量
    +0x030: 等级
    +0x034: 经验值
    ...
```

#### 3.3.3 指针扫描详解

```
CE 指针扫描流程
│
├── 准备工作
│   1. 找到目标数据的当前地址（如 0x12345678）
│   2. 记录当前地址
│   3. 不要关闭游戏
│
├── 第一次扫描
│   1. Memory View -> Tools -> Pointer scan
│   2. 设置参数：
│   │   ├── Address to find: 目标地址
│   │   ├── Max level: 5-7（指针层级）
│   │   ├── Max offset: 0x1000-0x2000
│   │   └── 勾选必要选项
│   3. 开始扫描（可能需要几分钟）
│   4. 保存结果
│
├── 验证过滤
│   1. 重启游戏
│   2. 重新找到目标数据的新地址
│   3. 在指针扫描结果中 "Rescan memory"
│   4. 输入新地址
│   5. 过滤掉无效的指针
│   6. 重复多次直到结果稳定
│
├── 选择最佳指针
│   ├── 层级越少越好（稳定性高）
│   ├── 偏移越小越好
│   ├── 基址是模块地址优先
│   └── 多次验证确保稳定
│
└── 指针链使用
    最终格式：[[[[game.exe+0xABC]+0x10]+0x20]+0x30]+0x40

    代码读取示例（C++）：
    DWORD base = (DWORD)GetModuleHandle("game.exe") + 0xABC;
    DWORD ptr1 = *(DWORD*)base;
    DWORD ptr2 = *(DWORD*)(ptr1 + 0x10);
    DWORD ptr3 = *(DWORD*)(ptr2 + 0x20);
    DWORD ptr4 = *(DWORD*)(ptr3 + 0x30);
    int health = *(int*)(ptr4 + 0x40);
```

#### 3.3.4 实战案例：找血量偏移

```
完整实战流程
│
├── 第1步：初步搜索
│   ├── 打开游戏，记录当前血量（假设是100）
│   ├── CE 搜索精确值 100，类型 4字节
│   ├── 找到几千个结果
│   ├── 受伤后血量变为 80
│   └── 再次搜索 80，结果缩小到几十个
│
├── 第2步：确定目标
│   ├── 继续改变血量并搜索
│   ├── 最终找到 1-3 个地址
│   ├── 修改这些地址的值验证
│   └── 确定真正的血量地址：0x1234ABCD
│
├── 第3步：分析代码
│   ├── 对地址下"写入断点"
│   ├── 受伤触发断点
│   ├── 看到代码：
│   │   mov [esi+0x120], eax
│   └── 得知偏移 0x120 是血量在对象中的偏移
│
├── 第4步：追踪基址
│   ├── 分析 esi 从哪来
│   ├── 向上追踪代码
│   │   mov esi, [0x00ABC000]
│   │   mov esi, [esi+0x50]
│   │   mov esi, [esi+0x10]
│   └── 得到指针链
│
├── 第5步：构建指针
│   ├── 基址：game.exe+0xABC000
│   ├── 一级偏移：+0x50
│   ├── 二级偏移：+0x10
│   ├── 血量偏移：+0x120
│   └── 完整：[[[game.exe+0xABC000]+0x50]+0x10]+0x120
│
└── 第6步：验证指针
    ├── 在 CE 中添加指针
    ├── 重启游戏验证
    ├── 多次测试确保稳定
    └── 保存到 Cheat Table
```

---

### 3.4 游戏引擎逆向

#### 3.4.1 引擎识别

```
常见游戏引擎识别方法
│
├── Unity 引擎
│   ├── 文件特征
│   │   ├── UnityPlayer.dll
│   │   ├── Assembly-CSharp.dll
│   │   ├── *.assets 资源文件
│   │   ├── globalgamemanagers
│   │   └── level* 场景文件
│   ├── 进程特征
│   │   ├── mono.dll（Mono模式）
│   │   └── GameAssembly.dll（IL2CPP模式）
│   └── 目录结构
│       ├── *_Data/ 文件夹
│       └── Managed/ 文件夹
│
├── Unreal Engine
│   ├── 文件特征
│   │   ├── *.pak 打包文件
│   │   ├── Engine/ 目录
│   │   ├── Content/ 目录
│   │   └── Binaries/ 目录
│   ├── 进程特征
│   │   ├── UE4Game-*.exe
│   │   └── 特定导出函数
│   └── 内存特征
│       ├── GObjects 数组
│       ├── GNames 数组
│       └── UWorld 指针
│
├── Source Engine
│   ├── 文件特征
│   │   ├── *.vpk 打包文件
│   │   ├── *.bsp 地图文件
│   │   └── *.mdl 模型文件
│   └── 模块特征
│       ├── client.dll
│       ├── engine.dll
│       └── server.dll
│
└── 自研引擎
    ├── 分析方法
    │   ├── 字符串搜索
    │   ├── 版权信息
    │   ├── 第三方库特征
    │   └── 代码模式分析
    └── 常见第三方库
        ├── DirectX（d3d9.dll/d3d11.dll）
        ├── OpenGL（opengl32.dll）
        ├── PhysX（PhysX*.dll）
        └── FMOD（fmod*.dll）
```

#### 3.4.2 Unity 游戏逆向

```
Unity 游戏逆向
│
├── Mono 模式（较老/未加密）
│   │
│   ├── 直接反编译
│   │   ├── 工具：dnSpy / ILSpy / dotPeek
│   │   ├── 目标：Assembly-CSharp.dll
│   │   └── 完整源码级别的分析
│   │
│   ├── 分析流程
│   │   1. 用 dnSpy 打开 Assembly-CSharp.dll
│   │   2. 搜索关键字（Health, Damage, Player等）
│   │   3. 找到相关类和方法
│   │   4. 分析代码逻辑
│   │   5. 修改 IL 代码或提取偏移
│   │
│   └── 常见类结构
│       ├── Player / Character
│       ├── GameManager
│       ├── UIManager
│       └── NetworkManager
│
├── IL2CPP 模式（新版/加密）
│   │
│   ├── 分析工具
│   │   ├── Il2CppDumper：导出类/方法信息
│   │   ├── Il2CppInspector：生成头文件
│   │   ├── Cpp2IL：代码还原
│   │   └── Frida + Il2Cpp 脚本
│   │
│   ├── 分析流程
│   │   1. 运行 Il2CppDumper
│   │   │   输入：GameAssembly.dll + global-metadata.dat
│   │   │   输出：dump.cs（类结构）
│   │   │         script.json（偏移信息）
│   │   2. 在 IDA 中加载 GameAssembly.dll
│   │   3. 运行 IDA 脚本还原符号
│   │   4. 通过偏移定位函数
│   │   5. 分析 native 代码
│   │
│   └── 关键文件
│       ├── GameAssembly.dll：编译后的代码
│       ├── global-metadata.dat：元数据
│       └── il2cpp_data/：类型信息
│
└── 常见 HOOK 点
    ├── Update()：每帧调用
    ├── Start()：初始化
    ├── OnTriggerEnter()：碰撞检测
    ├── TakeDamage()：受伤函数
    └── AddItem()：获得物品
```

#### 3.4.3 Unreal Engine 逆向

```
Unreal Engine 逆向
│
├── SDK 生成
│   ├── 工具选择
│   │   ├── Dumper-7：最新推荐
│   │   ├── UnrealDumper
│   │   └── UE4SS（支持脚本）
│   │
│   ├── 生成流程
│   │   1. 注入 Dumper 到游戏进程
│   │   2. 等待 SDK 生成完成
│   │   3. 获得 C++ 头文件
│   │   4. 在项目中使用 SDK
│   │
│   └── SDK 内容
│       ├── 所有类定义
│       ├── 属性偏移
│       ├── 函数指针
│       └── 枚举定义
│
├── 核心概念
│   ├── GObjects
│   │   ├── 全局对象数组
│   │   ├── 存储所有 UObject
│   │   └── 通过索引访问
│   │
│   ├── GNames
│   │   ├── 全局名称表
│   │   ├── 字符串池
│   │   └── 通过索引获取名称
│   │
│   ├── UWorld
│   │   ├── 当前世界指针
│   │   ├── 包含所有 Actor
│   │   └── 场景管理
│   │
│   └── 类继承
│       UObject
│       └── AActor
│           ├── APawn
│           │   └── ACharacter
│           │       └── APlayerCharacter
│           └── AController
│               └── APlayerController
│
├── 常用偏移查找
│   ├── GObjects：搜索特征码
│   ├── GNames：搜索特征码
│   ├── UWorld：引擎固定偏移
│   └── 其他：SDK 中查找
│
└── HOOK 技术
    ├── ProcessEvent HOOK
    │   ├── 所有蓝图函数调用都经过
    │   └── 可以拦截/修改/调用
    ├── 虚函数 HOOK
    │   └── 针对特定类的特定函数
    └── Tick HOOK
        └── 每帧执行
```

#### 3.4.4 引擎通用分析技巧

```
通用分析技巧
│
├── 渲染相关
│   ├── DirectX HOOK
│   │   ├── Present：每帧渲染完成
│   │   ├── DrawIndexed：绘制调用
│   │   └── 用于 ESP/透视
│   └── OpenGL HOOK
│       ├── wglSwapBuffers
│       └── glDrawElements
│
├── 输入相关
│   ├── GetAsyncKeyState HOOK
│   ├── DirectInput HOOK
│   └── RawInput HOOK
│
├── 网络相关
│   ├── send/recv HOOK
│   ├── WSASend/WSARecv HOOK
│   └── 引擎网络函数
│
└── 实体遍历
    ├── 从 World 获取 Level
    ├── 从 Level 获取 Actor 列表
    ├── 遍历筛选目标实体
    └── 读取实体属性
```

---

### 3.5 游戏封包分析

#### 3.5.1 封包基础

```
网络封包基础
│
├── 封包结构
│   │
│   ├── 常见格式
│   │   ┌─────────┬─────────┬─────────┬─────────┐
│   │   │ 包长度  │ 包类型  │ 序列号  │ 包数据  │
│   │   │ 2-4字节 │ 2字节   │ 4字节   │ 变长    │
│   │   └─────────┴─────────┴─────────┴─────────┘
│   │
│   ├── 包头字段
│   │   ├── 长度：整个包或数据部分的长度
│   │   ├── 类型/命令：标识封包功能
│   │   ├── 序列号：防重放、确保顺序
│   │   └── 校验：CRC/MD5验证完整性
│   │
│   └── 包体数据
│       ├── 固定结构
│       ├── TLV 格式（Type-Length-Value）
│       └── Protobuf/JSON/自定义
│
├── 协议类型
│   ├── TCP 协议
│   │   ├── 面向连接，可靠传输
│   │   ├── 需要处理粘包/拆包
│   │   └── 大多数游戏使用
│   │
│   ├── UDP 协议
│   │   ├── 无连接，快速传输
│   │   ├── FPS/动作游戏常用
│   │   └── 需要自己处理可靠性
│   │
│   └── HTTP/WebSocket
│       ├── 网页游戏常用
│       ├── 手游常用
│       └── 分析相对简单
│
└── 加密方式
    ├── 无加密（直接明文）
    ├── 简单异或
    ├── 对称加密（AES/DES）
    ├── 非对称加密（RSA）
    └── 混合加密
```

#### 3.5.2 抓包方法

```
抓包方法
│
├── 方法一：网络层抓包
│   ├── 工具：Wireshark
│   ├── 优点：不影响游戏
│   ├── 缺点：只能看加密后的数据
│   └── 适用：分析协议格式、定位加密前后
│
├── 方法二：HOOK 收发函数
│   │
│   ├── Windows Socket API
│   │   ├── send / recv
│   │   ├── WSASend / WSARecv
│   │   └── sendto / recvfrom
│   │
│   ├── 实现方式
│   │   ├── Inline HOOK
│   │   ├── IAT HOOK
│   │   └── Detours 库
│   │
│   ├── HOOK 示例代码
│   │   ```cpp
│   │   // 原始函数指针
│   │   int (WINAPI* original_send)(SOCKET s, const char* buf, int len, int flags);
│   │
│   │   // HOOK 函数
│   │   int WINAPI hooked_send(SOCKET s, const char* buf, int len, int flags) {
│   │       // 打印/保存封包数据
│   │       LogPacket("SEND", buf, len);
│   │       // 调用原函数
│   │       return original_send(s, buf, len, flags);
│   │   }
│   │   ```
│   │
│   └── 优点：获取原始数据
│
├── 方法三：游戏内部 HOOK
│   ├── 找到游戏的封包处理函数
│   ├── HOOK 加密前/解密后的位置
│   ├── 获取完全明文的数据
│   └── 最有效但难度最高
│
└── 方法四：代理/中间人
    ├── 搭建代理服务器
    ├── 游戏连接代理
    ├── 代理转发并记录
    └── 适用于 HTTP/WebSocket
```

#### 3.5.3 封包分析流程

```
封包分析流程
│
├── 第1步：抓取封包
│   ├── 使用 Wireshark 抓取原始流量
│   ├── 按 TCP 流分组查看
│   ├── 初步判断加密情况
│   └── 记录封包样本
│
├── 第2步：识别封包结构
│   ├── 观察封包规律
│   │   ├── 相同操作产生相似封包
│   │   ├── 找出固定部分（包头）
│   │   └── 找出变化部分（包体）
│   ├── 分析包头
│   │   ├── 长度字段位置
│   │   ├── 类型字段位置
│   │   └── 字节序（大端/小端）
│   └── 分析包体
│       ├── 尝试解析常见格式
│       └── 对比不同操作的封包
│
├── 第3步：分析加密
│   │
│   ├── 判断是否加密
│   │   ├── 数据是否可读
│   │   ├── 熵值是否很高
│   │   └── 是否有固定模式
│   │
│   ├── 定位加密函数
│   │   ├── HOOK send 找调用栈
│   │   ├── 在 send 前下断点
│   │   ├── 向上回溯找加密点
│   │   └── 分析加密算法
│   │
│   └── 常见加密特征
│       ├── 异或：简单，有规律
│       ├── RC4：流密码，初始化明显
│       ├── AES：块密码，有 S-Box
│       └── 自定义：需要具体分析
│
├── 第4步：协议逆向
│   │
│   ├── 分析方法
│   │   ├── 对比法：相同操作不同参数
│   │   ├── 触发法：执行操作看封包
│   │   └── 代码法：从游戏代码分析
│   │
│   ├── 字段识别
│   │   ├── 整数：坐标、ID、数量
│   │   ├── 字符串：名称、消息
│   │   ├── 浮点数：坐标、速度
│   │   └── 标志位：状态、属性
│   │
│   └── 记录协议
│       ├── 包类型编号
│       ├── 字段定义
│       ├── 数据类型
│       └── 含义说明
│
└── 第5步：实现发包
    ├── 构造封包数据
    ├── 加密处理
    ├── 发送封包
    └── 处理响应
```

#### 3.5.4 实战：分析登录封包

```
示例：分析登录封包
│
├── 抓包观察
│   │
│   │ 登录请求（假设已解密）：
│   │ 00000000: 00 1A 00 01 00 00 00 01  74 65 73 74 75 73 65 72
│   │ 00000010: 00 31 32 33 34 35 36 00
│   │
│   └── 初步分析：
│       ├── 00 1A：长度 26 字节
│       ├── 00 01：命令类型 1（登录）
│       ├── 00 00 00 01：序列号 1
│       ├── 74 65 73 74...：用户名 "testuser"
│       └── 31 32 33 34...：密码 "123456"
│
├── 结构定义
│   │
│   │ struct LoginPacket {
│   │     uint16_t length;      // 包长度
│   │     uint16_t command;     // 命令: 0x0001
│   │     uint32_t sequence;    // 序列号
│   │     char username[0];     // 用户名（NULL结尾）
│   │     char password[0];     // 密码（NULL结尾）
│   │ };
│   │
│   └── 发现规律：
│       ├── 长度 = 2 + 2 + 4 + strlen(username) + 1 + strlen(password) + 1
│       └── 字符串使用 NULL 结尾
│
├── 加密分析
│   ├── 对比加密前后数据
│   ├── 发现是简单异或
│   ├── 密钥为固定字节
│   └── 还原异或函数
│
└── 模拟登录
    ```python
    import socket
    import struct

    def build_login_packet(username, password):
        cmd = 0x0001
        seq = 1
        data = username.encode() + b'\x00' + password.encode() + b'\x00'
        length = 2 + 2 + 4 + len(data)

        packet = struct.pack('>HHI', length, cmd, seq) + data
        return xor_encrypt(packet)

    def xor_encrypt(data):
        key = 0x5A
        return bytes([b ^ key for b in data])
    ```
```

---

## 四、第三阶段：移动端逆向

### 4.1 Android 逆向

#### 4.1.1 基础知识

```
Android 逆向基础
│
├── APK 结构
│   ├── AndroidManifest.xml：应用配置
│   ├── classes.dex：Java/Kotlin 代码
│   ├── lib/：Native 库（.so 文件）
│   │   ├── armeabi-v7a/
│   │   ├── arm64-v8a/
│   │   └── x86/
│   ├── res/：资源文件
│   ├── assets/：原始资源
│   └── META-INF/：签名信息
│
├── 代码类型
│   ├── Java/Kotlin 代码
│   │   ├── 编译为 DEX 字节码
│   │   └── 可反编译为 Java
│   ├── Native 代码（C/C++）
│   │   ├── 编译为 .so 文件
│   │   └── 需要汇编级分析
│   └── Unity IL2CPP
│       ├── libil2cpp.so
│       └── 需要特殊处理
│
└── 常用工具
    ├── 解包：apktool, jadx
    ├── 反编译：jadx, JEB, GDA
    ├── 调试：IDA, GDB, LLDB
    ├── HOOK：Frida, Xposed, LSPosed
    └── 抓包：Charles, mitmproxy
```

#### 4.1.2 Java 层分析

```
Java 层逆向
│
├── 反编译工具
│   │
│   ├── jadx（推荐）
│   │   ├── 图形界面友好
│   │   ├── 反编译效果好
│   │   ├── 支持搜索
│   │   └── 可导出项目
│   │
│   ├── JEB
│   │   ├── 专业付费工具
│   │   ├── 动态调试支持
│   │   ├── 脚本扩展
│   │   └── 反混淆能力强
│   │
│   └── GDA
│   │   ├── 国产免费工具
│   │   └── 支持交叉引用
│
├── 分析流程
│   1. 使用 jadx 打开 APK
│   2. 搜索关键字符串
│   3. 找到目标类和方法
│   4. 分析代码逻辑
│   5. 定位关键函数
│
├── 常见混淆
│   ├── ProGuard
│   │   ├── 类名混淆（a, b, c...）
│   │   ├── 方法名混淆
│   │   └── 可通过逻辑分析
│   ├── DexGuard
│   │   ├── 字符串加密
│   │   ├── 代码加密
│   │   └── 需要动态分析
│   └── 整体加固
│       ├── 360加固、腾讯乐固等
│       ├── DEX 加密
│       └── 需要脱壳处理
│
└── 脱壳方法
    ├── Frida Dump DEX
    ├── 定制系统脱壳
    ├── FART 脱壳机
    └── BlackDex 脱壳
```

#### 4.1.3 Native 层分析

```
Native 层逆向（.so 文件）
│
├── 分析工具
│   ├── IDA Pro
│   │   ├── 支持 ARM/ARM64
│   │   ├── 动态调试
│   │   └── 最强大的选择
│   ├── Ghidra
│   │   ├── 免费替代
│   │   └── ARM 支持良好
│   └── Binary Ninja
│       └── 中间价位选择
│
├── ARM 汇编基础
│   ├── 寄存器
│   │   ├── R0-R12：通用寄存器
│   │   ├── SP (R13)：栈指针
│   │   ├── LR (R14)：链接寄存器
│   │   ├── PC (R15)：程序计数器
│   │   └── CPSR：状态寄存器
│   ├── ARM64 寄存器
│   │   ├── X0-X30：64位通用
│   │   ├── W0-W30：32位视图
│   │   ├── SP：栈指针
│   │   └── PC：程序计数器
│   └── 调用约定
│       ├── ARM32：R0-R3 传参
│       └── ARM64：X0-X7 传参
│
├── 分析技巧
│   ├── JNI 函数识别
│   │   ├── 函数名：Java_包名_类名_方法名
│   │   ├── 导出表搜索
│   │   └── 动态注册查找
│   ├── 字符串定位
│   │   ├── Strings 窗口
│   │   ├── 交叉引用
│   │   └── 加密字符串解密
│   └── 加密算法识别
│       ├── 特征常量搜索
│       ├── 算法模式识别
│       └── FindCrypt 插件
│
└── 动态调试
    ├── IDA + android_server
    ├── GDB + gdbserver
    ├── LLDB 调试
    └── Frida 动态分析
```

#### 4.1.4 Frida 使用

```
Frida 动态分析框架
│
├── 环境搭建
│   ├── PC 端安装 frida-tools
│   │   pip install frida-tools
│   ├── 手机端安装 frida-server
│   │   ├── 下载对应架构版本
│   │   ├── push 到 /data/local/tmp
│   │   └── 给予执行权限并运行
│   └── 需要 root 权限
│
├── 基础用法
│   ├── 列出进程
│   │   frida-ps -U
│   ├── 附加进程
│   │   frida -U -n "游戏名" -l script.js
│   ├── 启动并注入
│   │   frida -U -f com.game.package -l script.js
│   └── 交互模式
│       frida -U -n "游戏名"
│
├── JavaScript API
│   │
│   ├── Java HOOK
│   │   ```javascript
│   │   Java.perform(function() {
│   │       var TargetClass = Java.use("com.game.Player");
│   │
│   │       TargetClass.getHealth.implementation = function() {
│   │           var result = this.getHealth();
│   │           console.log("Health: " + result);
│   │           return result;
│   │       };
│   │   });
│   │   ```
│   │
│   ├── Native HOOK
│   │   ```javascript
│   │   var targetFunc = Module.findExportByName("libgame.so", "getPlayerHP");
│   │
│   │   Interceptor.attach(targetFunc, {
│   │       onEnter: function(args) {
│   │           console.log("Called with: " + args[0]);
│   │       },
│   │       onLeave: function(retval) {
│   │           console.log("Return: " + retval);
│   │       }
│   │   });
│   │   ```
│   │
│   └── 内存操作
│       ```javascript
│       // 读取内存
│       var addr = ptr("0x12345678");
│       console.log(Memory.readInt(addr));
│
│       // 写入内存
│       Memory.writeInt(addr, 9999);
│
│       // 搜索内存
│       Memory.scan(baseAddr, size, pattern, callbacks);
│       ```
│
└── 常用脚本
    ├── SSL Pinning 绑定
    ├── Root 检测绕过
    ├── 签名校验绕过
    └── 加解密函数 HOOK
```

---

### 4.2 iOS 逆向

#### 4.2.1 基础知识

```
iOS 逆向基础
│
├── 环境要求
│   ├── 越狱设备
│   │   ├── checkra1n（A11及以下）
│   │   ├── unc0ver
│   │   └── Taurine
│   ├── Mac 电脑（部分工具需要）
│   └── 或使用已越狱的虚拟机
│
├── IPA 结构
│   ├── Payload/App.app/
│   │   ├── Info.plist：应用配置
│   │   ├── 可执行文件（Mach-O）
│   │   ├── Frameworks/：依赖框架
│   │   └── 资源文件
│   └── 签名文件
│
├── Mach-O 文件
│   ├── 类型
│   │   ├── 可执行文件
│   │   ├── 动态库（.dylib）
│   │   └── 框架（.framework）
│   ├── 结构
│   │   ├── Header
│   │   ├── Load Commands
│   │   └── Segments/Sections
│   └── 加密（FairPlay DRM）
│       └── 需要砸壳解密
│
└── 常用工具
    ├── 砸壳：Clutch, dumpdecrypted, frida-ios-dump
    ├── 分析：IDA, Hopper, class-dump
    ├── HOOK：Frida, Theos（Tweak开发）
    └── 抓包：Charles + SSL Proxy
```

#### 4.2.2 砸壳与分析

```
iOS 砸壳
│
├── 方法一：frida-ios-dump（推荐）
│   ├── 安装
│   │   pip install frida-tools
│   │   git clone frida-ios-dump
│   ├── 使用
│   │   python dump.py 应用名
│   └── 自动完成砸壳
│
├── 方法二：Clutch
│   ├── 安装到越狱设备
│   ├── Clutch -d 应用名
│   └── 导出解密 IPA
│
├── 方法三：dumpdecrypted
│   ├── 编译 dumpdecrypted.dylib
│   ├── 注入到目标进程
│   └── 导出解密二进制
│
└── 分析流程
    1. 砸壳获取解密的可执行文件
    2. class-dump 导出头文件
    3. IDA 加载分析
    4. 配合 Frida 动态分析
```

#### 4.2.3 iOS Frida 使用

```
iOS Frida 分析
│
├── 环境搭建
│   ├── 越狱设备安装 Frida
│   │   Cydia 添加源：https://build.frida.re
│   │   安装 Frida
│   ├── PC 端安装工具
│   │   pip install frida-tools
│   └── USB 连接设备
│
├── Objective-C HOOK
│   ```javascript
│   // HOOK OC 方法
│   var className = "Player";
│   var methodName = "- getHealth";
│
│   var hook = ObjC.classes[className][methodName];
│   Interceptor.attach(hook.implementation, {
│       onEnter: function(args) {
│           // args[0] = self, args[1] = _cmd
│           console.log("Called getHealth");
│       },
│       onLeave: function(retval) {
│           console.log("Health: " + retval);
│       }
│   });
│   ```
│
├── Swift HOOK
│   ├── Swift 方法名有修饰
│   ├── 需要找到真实符号名
│   └── 使用 Module.enumerateSymbols 查找
│
└── 常用功能
    ├── 绕过越狱检测
    ├── 绕过 SSL Pinning
    ├── 内存搜索与修改
    └── 方法追踪
```

---

## 五、实战项目建议

### 5.1 练习项目

```
从易到难的练习路线
│
├── 入门级
│   ├── Windows 计算器逆向
│   ├── 简单 CrackMe 程序
│   ├── 单机小游戏修改器
│   └── 控制台程序分析
│
├── 初级
│   ├── 单机游戏数据修改
│   ├── 找血量/金币偏移
│   ├── 指针扫描练习
│   └── 简单注入程序
│
├── 中级
│   ├── Unity 游戏分析
│   ├── 网络游戏封包分析
│   ├── 加密算法还原
│   └── DLL 注入 + HOOK
│
├── 高级
│   ├── UE4 游戏 SDK 生成
│   ├── 完整的辅助工具
│   ├── 对抗反作弊
│   └── 移动端逆向
│
└── 专家级
    ├── 内核级分析
    ├── 反反调试
    ├── 自定义引擎分析
    └── 商业级工具开发
```

### 5.2 学习时间规划

```
完整学习路线时间规划
│
├── 第1-2月：基础打牢
│   ├── C/C++ 语言（40小时）
│   ├── x86 汇编（60小时）
│   ├── Windows 基础（20小时）
│   └── 工具熟悉（20小时）
│
├── 第3-4月：PC 逆向入门
│   ├── IDA Pro 使用（40小时）
│   ├── x64dbg 调试（40小时）
│   ├── CE 内存分析（30小时）
│   └── 简单游戏分析（40小时）
│
├── 第5-6月：深入学习
│   ├── 引擎逆向（60小时）
│   ├── 封包分析（40小时）
│   ├── HOOK 技术（40小时）
│   └── 实战项目（60小时）
│
├── 第7-8月：移动端扩展
│   ├── Android 逆向（60小时）
│   ├── iOS 逆向（40小时）
│   ├── Frida 框架（40小时）
│   └── 综合项目（60小时）
│
└── 持续：进阶提升
    ├── 阅读安全博客
    ├── 跟进新技术
    ├── 参与 CTF
    └── 真实项目实战
```

---

## 六、工具清单汇总

### 6.1 PC 端工具

| 类别 | 工具 | 用途 | 价格 |
|------|------|------|------|
| 反汇编 | IDA Pro | 静态分析 | 付费 |
| 反汇编 | Ghidra | 静态分析 | 免费 |
| 调试器 | x64dbg | 动态调试 | 免费 |
| 调试器 | WinDbg | 内核调试 | 免费 |
| 内存 | Cheat Engine | 内存分析 | 免费 |
| 抓包 | Wireshark | 网络分析 | 免费 |
| PE分析 | CFF Explorer | PE结构 | 免费 |
| .NET | dnSpy | 反编译 | 免费 |
| Unity | Il2CppDumper | 分析 | 免费 |

### 6.2 移动端工具

| 类别 | 工具 | 平台 | 用途 |
|------|------|------|------|
| 反编译 | jadx | Android | Java 反编译 |
| 反编译 | JEB | Android | 专业分析 |
| HOOK | Frida | 跨平台 | 动态分析 |
| HOOK | Xposed/LSPosed | Android | 系统级 HOOK |
| 抓包 | Charles | 跨平台 | HTTP 抓包 |
| 砸壳 | frida-ios-dump | iOS | 砸壳脱壳 |
| 分析 | class-dump | iOS | 头文件导出 |

---

## 七、学习资源

### 7.1 书籍推荐

```
基础书籍
├── 《汇编语言》- 王爽
├── 《C++ Primer》
├── 《深入理解计算机系统》
└── 《Windows核心编程》

逆向进阶
├── 《逆向工程核心原理》
├── 《加密与解密》- 段钢
├── 《IDA Pro权威指南》
└── 《恶意代码分析实战》

移动端
├── 《Android软件安全与逆向分析》
├── 《iOS应用逆向工程》
└── 《Android安全攻防权威指南》
```

### 7.2 在线资源

```
学习网站
├── 看雪论坛（kanxue.com）
├── 吾爱破解（52pojie.cn）
├── FreeBuf 安全社区
└── GitHub 开源项目

视频教程
├── B站 逆向工程教程
├── 看雪课程
└── YouTube 技术频道

实践平台
├── CrackMe 练习
├── CTF 比赛
└── 开源游戏分析
```

---

## 八、注意事项

> **重要声明**：
> 1. 本文档仅用于**技术学习和研究**目的
> 2. 逆向分析可能违反软件使用协议
> 3. 请勿用于非法目的
> 4. 建议在合法授权范围内进行学习
> 5. 尊重知识产权和他人劳动成果

---

**文档版本**：v1.0
**最后更新**：2025-11-24
